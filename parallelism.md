**PARALLELISM**

1. **Async Await how works?**

[Модель асинхронного программирования на основе задач (TAP)](https://docs.microsoft.com/ru-ru/dotnet/csharp/programming-guide/concepts/async/task-asynchronous-programming-model) предоставляет абстракцию асинхронного кода. Вы пишете код как последовательность операторов, как обычно. Вы можете читать этот код, как если бы каждая инструкция завершалась до начала следующей. Компилятор выполняет ряд преобразований, так как некоторые из этих инструкций могут начать работу и вернуть [Task](https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.tasks.task), представляющий текущую работу.

Асинхронное программирование позволяет избежать появления узких мест производительности и увеличить общую скорость реагирования приложения.

Асинхронность необходимо использовать при наличии потенциально блокирующих работу действий, например при осуществлении доступа к Интернету. Доступ к веб-ресурсу иногда осуществляется медленно или с задержкой. Если такое действие блокируется в синхронном процессе, все приложение вынуждено ожидать. В асинхронном процессе приложение может перейти к следующей операции, не зависящей от веб-ресурса, до завершения блокирующей задачи. Асинхронность особенно полезна в приложениях, которые обращаются к потоку пользовательского интерфейса, поскольку все связанные с пользовательским интерфейсом действия обычно используют один поток. В синхронном приложении блокировка одного процесса приводит к блокировке всех процессов. Приложение перестает отвечать, и это выглядит как сбой, а не как ожидание.

В C# основой асинхронного программирования. являются ключевые слова [async](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/async) и [await](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/await). Они позволяют использовать ресурсы платформы .NET Framework, .NET Core или среды выполнения Windows для создания асинхронных методов, и это почти так же просто, как создавать синхронные методы. Асинхронные методы, которые определяются с помощью ключевого слова async, называются методами async.

public async Task&lt;int&gt; GetUrlContentLengthAsync()

{

var client = new HttpClient();

Task&lt;string&gt; getStringTask =

client.GetStringAsync("<https://docs.microsoft.com/dotnet>");

DoIndependentWork();

string contents = await getStringTask;

return contents.Length;

}

void DoIndependentWork()

{

Console.WriteLine("Working...");

}

- Вызывающий метод вызывает и ожидает асинхронный метод GetUrlContentLengthAsync.
- GetUrlContentLengthAsync создает экземпляр [HttpClient](https://docs.microsoft.com/ru-ru/dotnet/api/system.net.http.httpclient) и вызывает асинхронный метод [GetStringAsync](https://docs.microsoft.com/ru-ru/dotnet/api/system.net.http.httpclient.getstringasync), чтобы загрузить содержимое веб-сайта в виде строки.
- В GetStringAsync происходит событие, которое приостанавливает ход выполнения. Например, методу необходимо подождать завершения загрузки или произошло другое блокирующее действие. Чтобы избежать блокировки ресурсов, GetStringAsync передает управление вызывающему объекту GetUrlContentLengthAsync.
  - - GetStringAsync возвращает [Task&lt;TResult&gt;](https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.tasks.task-1), где TResult — строка, а GetUrlContentLengthAsync присваивает задачу переменной getStringTask. Задача представляет собой непрерывный процесс для вызова GetStringAsync с обязательством создать фактическое значение строки, когда работа будет завершена.
- Поскольку значение из процесса getStringTask еще не получено, метод GetUrlContentLengthAsync может перейти к другим операциям, не зависящим от конечного результатаGetStringAsync. Эти операции представлены вызовом синхронного метода DoIndependentWork.
- DoIndependentWork — это синхронный метод, который выполняет свой код и возвращает управление вызывающему объекту.
- Метод GetUrlContentLengthAsync выполнил все операции, для которых не требуется результат процесса getStringTask. Далее метод GetUrlContentLengthAsync должен вычислить длину загруженной строки и возвратить ее, но не может этого сделать, пока нет строки.
  - - Поэтому GetUrlContentLengthAsync использует оператор await, чтобы приостановить свою работу и передать управление методу, вызвавшему GetUrlContentLengthAsync. GetUrlContentLengthAsync возвращает вызывающему объекту Task&lt;int&gt;. Задача представляет собой обещание создать целочисленный результат, являющийся длиной загруженной строки.
      - **Примечание**
      - Если метод GetStringAsync (и, следовательно, процесс getStringTask) завершается прежде, чем этого дождется GetUrlContentLengthAsync, управление остается у метода GetUrlContentLengthAsync. На приостановку метода GetUrlContentLengthAsync и последующий возврат к нему были бы потрачены лишние ресурсы, если вызываемый асинхронный процесс getStringTask уже завершен и GetUrlContentLengthAsync не нужно ждать окончательного результата.
      - В вызывающем методе сохраняется шаблон обработки. Вызывающий объект может выполнять другие операции, не зависящие от результата GetUrlContentLengthAsync, во время ожидания этого результата, или сразу ожидать результата. Вызывающий метод ожидает GetUrlContentLengthAsync, а GetUrlContentLengthAsync ожидает GetStringAsync.
- GetStringAsync завершается и создает строковый результат. Вызов возвращает строковый результат в метод GetStringAsync, но не так, как, возможно, ожидалось. (Помните, что метод уже возвратил задачу в шаге 3.) Вместо этого строковый результат хранится в задаче getStringTask, которая представляет собой завершение метода. Оператор await извлекает результат из getStringTask. Оператор присваивания назначает извлеченный результат contents.
- Если GetUrlContentLengthAsync содержит строковый результат, метод может вычислить длину строки. Затем работа GetUrlContentLengthAsync также завершена, и ожидающий обработчик событий может возобновить работу. В полном примере в конце этого раздела видно, что обработчик событий извлекает значение длины и выводит результат. Если вы недавно занимаетесь асинхронным программированием, рекомендуем обратить внимание на различия между синхронным и асинхронным поведением. Синхронный метод возвращает управление, когда его работа завершается (шаг 5), тогда как асинхронный метод возвращает значение задачи, когда его работа приостанавливается (шаги 3 и 6). Когда асинхронный метод в конечном счете завершает работу, задача помечается как завершенная и результат, при его наличии, сохраняется в задаче.

Асинхронные методы используются для неблокирующих операций. Выражение await в асинхронном методе не блокирует текущий поток на время выполнения ожидаемой задачи. Вместо этого выражение регистрирует остальную часть метода как продолжение и возвращает управление вызывающему объекту асинхронного метода.

Ключевые слова async и await не вызывают создания дополнительных потоков. Асинхронные методы не требуют многопоточности, поскольку асинхронный метод не выполняется в собственном потоке. Метод выполняется в текущем контексте синхронизации и использует время в потоке, только когда метод активен. Метод [Task.Run](https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.tasks.task.run) можно применять для перемещения операций, использующих ресурсы ЦП, в фоновый поток, однако фоновый поток не имеет смысла применять для процесса, который просто ждет результата.

Если с помощью модификатора [async](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/async) указать, что метод является асинхронным, у вас появятся следующие две возможности.

- Асинхронный метод сможет использовать [await](https://docs.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/await) для обозначения точек приостановки. Оператор await сообщает компилятору, что асинхронный метод не может выполняться после этой точки до завершения ожидаемого асинхронного процесса. На это время управление возвращается вызывающему объекту асинхронного метода.

Приостановка асинхронного метода на выражении await не считается выходом из метода, и блоки finally не выполняются.

- Сам обозначенный асинхронный метод может ожидаться вызывающими его методами.

Асинхронный метод обычно содержит одно или несколько вхождений оператора await, но отсутствие выражений await не вызывает ошибок компилятора. Если асинхронный метод не использует оператор await для обозначения точки приостановки, метод выполняется как синхронный независимо от наличия модификатора async. При компиляции таких методов выдается предупреждение.

1. **Threads synchronization**
2.  **Task.ConfigureAwait**

При использовании ключевого слова await компилятор делает много чего интересного, но в данном случае нас интересует, то что происходит запоминание (_на самом деле запоминается и другие контексты_) контекста синхронизации SynchronizationContext, который предназначен для исполнения кода в потоке конкретного вида. В классе SynchronizationContext есть важный метод Post, который гарантирует, что переданный делегат будет исполняться в правильном контексте.

Так вот, мы помним, что код, предшествующий первому await, _исполняется в вызывающем потоке_, но что происходит, когда исполнение вашего метода возобновляется после await? На самом деле, _в большинстве случаев_ он также _исполняется в вызывающем потоке_, несмотря на то, что в промежутке вызывающий поток мог делать что-то еще. Для достижения такого эффекта текущий контекст SynchronizationContext **сохраняется** (это происходимит при встрече оператора await). Далее, когда метод возобновляется, компилятор вставляет вызов Post, чтобы исполнение возобновилось в запомненном контексте. Как правило, вызов этого метода обходится сравнительно дорого. Поэтому, чтобы избежать накладных расходов, **.NET** не вызывает Post, если запомненный контекст синхронизации совпадает с текущим на момент завершения задачи. Однако если контексты синхронизации различаются, то необходим дорогостоящий вызов Post. Если производительность стоит на первом месте или речь идет о библиотечном коде, которому безразлично, в каком потоке выполняться, то, возможно, не имеет смысла нести такие расходы. Поэтому, в таком случае следует вызвать метод ConigureAwait(false) перед тем как ждать его. Важно понимать, что данный метод задуман как способ информирования **.NET** о том, что **вам безразлично, в каком потоке будет возобновлено выполнение**. Если этот поток не очень важен, например взят из пула, то исполнение кода в нем и продолжится. Но если поток по какой-то причине важен, то **.NET** предпочтет освободить его для других дел, а исполнение вашего метода продолжить в потоке, взятом из пула. Решение о том, важен поток или нет, принимается на основе анализа текущего контекста синхронизации.

1. **ThreadPool. How it works?**

Создание потоков требует времени. Если есть различные короткие задачи, подлежащие выполнению, можно создать набор потоков заранее и затем просто отправлять соответствующие запросы, когда наступает очередь для их выполнения. Было бы неплохо, если бы количество этих потоков автоматически увеличивалось с ростом потребности в потоках и уменьшалось при возникновении потребности в освобождении ресурсов.

Создавать подобный список потоков самостоятельно не понадобится. Для управления таким списком предусмотрен класс ThreadPool, который по мере необходимости уменьшает и увеличивает количество потоков в пуле до максимально допустимого. Значение максимально допустимого количества потоков в пуле может изменяться. В случае двуядерного ЦП оно по умолчанию составляет 1023 рабочих потоков и 1000 потоков ввода-вывода.

Можно указывать минимальное количество потоков, которые должны запускаться сразу после создания пула, и максимальное количество потоков, доступных в пуле. Если остались какие-то подлежащие обработке задания, а максимальное количество потоков в пуле уже достигнуто, то более новые задания будут помещаться в очередь и там ожидать, пока какой-то из потоков завершит свою работу.

Чтобы запросить поток из пула для обработки вызова метода, можно использовать метод QueueUserWorkItem(). Этот метод перегружен, чтобы в дополнение к экземпляру делегата WaitCallback позволить указывать необязательный параметр System.Object для специальных данных состояния.

class Program

{

static void Main()

{

int nWorkerThreads;

int nCompletionThreads;

ThreadPool.GetMaxThreads(out nWorkerThreads, out nCompletionThreads);

Console.WriteLine("Максимальное количество потоков: " + nWorkerThreads

\+ "\\nПотоков ввода-вывода доступно: " + nCompletionThreads);

for (int i = 0; i < 5; i++)

ThreadPool.QueueUserWorkItem(JobForAThread);

Thread.Sleep(3000);

Console.ReadLine();

}

static void JobForAThread(object state)

{

for (int i = 0; i < 3; i++)

{

Console.WriteLine("цикл {0}, выполнение внутри потока из пула {1}",

i, Thread.CurrentThread.ManagedThreadId);

Thread.Sleep(50);

}

}

}

Здесь может возникнуть вопрос: в чем же преимущество использования поддерживаемого CLR пула потоков по сравнению с явным созданием объектов Thread? Ниже перечислены эти преимущества:

Пул потоков управляет потоками эффективно, уменьшая количество создаваемых, запускаемых и останавливаемых потоков.

Используя пул потоков, можно сосредоточиться на решении задачи, а не на инфраструктуре потоков приложения.

Тем не менее, в некоторых случаях предпочтительно ручное управление потоками. Пулы потоков очень просты в применении, однако обладают рядом ограничений, которые перечислены ниже:

- Все потоки в пуле потоков являются фоновыми. В случае завершения работы всех приоритетных потоков в процессе работа всех фоновых потоков тоже останавливается. Сделать поток из пула приоритетным не удастся.
- Нельзя изменять приоритет или имя находящего в пуле потока. Все потоки в пуле представляют собой потоки многопоточного апартамента (multi-threaded apartment — МТА), а многие СОМ-объекты требуют использования потоков однопоточного апартамента (single-threaded apartment — STA).
- Потоки в пуле подходят для выполнения только коротких задач. Если необходимо, чтобы поток функционировал все время (как, например, поток средства проверки орфографии в Word), его следует создавать с помощью класса Thread.
- Нельзя создать поток с фиксированной идентичностью, чтобы можно было прерывать его или находить по имени.

1. **Thread blocking – how to optimize?**
2. **Difference between Threads and Tasks**

Tasks are wrapper around Thread and ThreadPool classes. Below are some major differences between Threads and Tasks:

- A Task can return a result but there is no proper way to return a result from Thread.
- We can apply chaining on multiple tasks but we can not in threads.
- We can wait on Tasks without using Signalling. But in Threads we have to use event signals like AutoResetEvent and ManualResetEvent.
- We can apply Parent/Child relationship in Tasks. A Task at one time becomes parent of multiple tasks. Parent Task does not complete until it's child tasks are completed. We do not have any such mechanim in Thread class.
- Child Tasks can propagate their exceptions to to parent Task and All child exceptions are available in AggregateException class.
- Tasks has in-build cancellation mechanism using CancellationToken clas